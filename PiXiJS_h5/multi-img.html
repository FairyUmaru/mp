<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,
 initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>Title</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        .content{
            width: 100vw;
            height: 100vh;
        }
        .main{
            display: flex;
        }
    </style>
</head>
<body>
<div class="content">
    <div class="main">
    </div>
</div>

</body>
<script src="js/jquery-3.3.1.min.js"></script>
<script src="./js/pixi4.8.0.js"></script>
<script>
    const w = document.body.clientWidth,
        h = document.body.clientHeight;

    const mainRenderer = new PIXI.CanvasRenderer({
        width: document.body.clientWidth,
        height: document.body.clientHeight,
        transparent: true,
        // 强制使用2d上下文进行渲染，如果为flase,则默认使用webgl渲染
        forceCanvas: true,
        // 设置resolution 为像素密度
        resolution: 1,
    })

    // 生成名为stage的容器（object）,可在这个舞台下创建多个舞台来管理多个场景
    var stage = new PIXI.Container();

    // 获取屏幕宽高，判断横屏还是竖屏
    let min = (w < h) ? w : h;
    let scale = min / 750;  // 根据设计稿尺寸进行缩放比例调整
    console.log(w, h, min, "放大系数：", scale);

    //资源预加载
    // 创建资源加载器，进行资源预加载
    const loader = new PIXI.loaders.Loader();
    loader.add('bg', './images/right.jpg')
        .add('child', './images/child.png')
    loader.on("progress", function (target, resource) {  // 加载进度
        console.log(parseInt(target.progress) + "%")
    });
    loader.once('complete', function (target, resource) {  // 加载完成
        console.log(11111)
        initScenes(stage); // 初始化场景
        initSprites();  // 初始化精灵
        // initAnimation(); // 初始化动画
        stage.scale.set(scale, scale);  // 根据屏幕实际宽高放大舞台
        stage.x = 0
        // if (w < h) {   // 根据横屏竖屏效果旋转舞台
        //     stage.rotation = 1.57;
        //     stage.pivot.set(0.5);
        //     stage.x = w;
        //     // initTouch(true, 'y');
        // } else {
        //     // initTouch(false, 'x');
        // }
    });
    loader.load();  // 加载资源
    //把渲染器添加到HTML结构里
    document.querySelector(".main").appendChild(mainRenderer.view);
    // renderer.render(stage)

    requestAnimationFrame(animate);


    // 在渲染器中传入stage。
    function onDragStart(e) {
        console.log('drag-start', e)
        console.log(e.data.getLocalPosition(this.parent));
        let newPosition = e.data.getLocalPosition(this.parent)
        let touch = e.data.originalEvent.changedTouches[0];
        offsetX = newPosition.x;
        offsetY = newPosition.y
    }
    function onDragMove(e) {
        // console.log('drag-move',  e)
        // console.log(e.data.getLocalPosition(this.parent));
        let newPosition = e.data.getLocalPosition(this.parent)
        // console.log(newPosition.x - offsetX)
        sprites.cat.x += newPosition.x - offsetX;
        console.log(sprites.cat.x)
        //判断x的边界（-图片宽度， 0）
        let x;
        if(sprites.cat.x > 0) {
            sprites.cat.x = 0
        }
        if(sprites.cat.x < -sprites.cat.width+document.body.clientWidth) {
            sprites.cat.x = -sprites.cat.width+document.body.clientWidth
        }
        offsetX = newPosition.x
        requestAnimationFrame(animate);
    }
    function onDragEnd(e) {
        console.log('drag-end', e)
    }

    function animate() {
        // stage.x = 0;
        //渲染到渲染器
        mainRenderer.render(stage);
        requestAnimationFrame(animate);
    }

</script>
<script src="js/scene.js"></script>
<script src="js/sprites.js"></script>
</html>